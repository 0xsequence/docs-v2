import {Callout} from 'vocs/components'

# Mint Collectibles from an Allowlist Token Sale Contract

Time to complete: X-X minutes

With the motion of crypto markets, it's common to keep the interest of users in your commuity by issuing frequent sales of collectibles. 

This allows teams and users to assess value in a feedback loop coming from a market, when exposed, and enables a sustainable model of business to support operating your cause.

The follow steps can be completed in order to launch your own token sale:

1. [Gather an Address List]()
2. [Create a Collection]()
3. [Deploy a Token Sale]()
4. [Clone a Frontend]()
5. [Setup a Merkletree Proof Generating Cloudflare Worker]()
6. [Mint Coins to Wallet]()
7. [Mint Collectible to Wallet]()

## 1. Gather an Address List

The first step is to asses the user you are marketing to. This way, you can tailor to the needs of their desire function and enhance the collective play of your community and the rest.

If you have an existing list, great, process to step 2

If not find a project, whether your own, or another on the blockchain (consent is best, leaving room for collaboration)

And obtain the contract address of the collection.

### User Funnel Best Practices

With an allowlist, the list can come from any evm based network, so bridging boundaries has both many advantages, as well as creates opportunities to craft new experiences of trust and ownership

A helpful mental model to view the problem through of recieving funds from trusted sources to enhance overall karma, can be seen in the following:

<div style={{ display: "flex", justifyContent: "center", alignItems: "center", width: "100%" }}>
	<img src="/img/guides/token-sale/trust_mental_model.png" width="400px" alt="trust mental model" />
</div>

Broken down as:
- mutualism: establishing others as equals
- dynamic criticism: evaluating ad-hoc and returning mutual values to implementation source 
- growth: expansion to replicate
- vulnerability: being available to the opened avenue of critique vectors
- movement: how the connection impacts the body 
- authenticity: how to make your community strong from internal values
- creation: crafting something that wasn't there
- collectivity: affordances for accessing a multi-part network

If you're deciding between projects, it might be useful to create a weighted score matrix across the facets of building a trust chain from an address list.

### Save Address List to File System

Run the following code in a nodejs script, by first creating a folder in terminal, confguring with `npx tsc --init` to create a `tsconfig.json` and running the code with `npx ts-node <file_name>`.

```ts
import { SequenceIndexer } from '@0xsequence/indexer'
//@ts-ignore
import fs from 'fs'

const indexer = new SequenceIndexer("https://polygon-indexer.sequence.app", "<access_key>");

(async () => {
    const txs = []
    // pass anything you would like
    const contractAddress = "<contract_address>";
    const includeMetadata = false;

    // Fetch tokens and collectibles owned by any wallet
    let result = await indexer.getTokenBalances({
        contractAddress,
        includeMetadata 
    })

    txs.push(...result.balances)

    // if there are more transactions to log, proceed to paginate
    while(result.page.more){  
        result = await indexer.getTokenBalances({
            contractAddress,
            includeMetadata,
            page: { 
                pageSize: 50, 
                // use the after cursor from the previous indexer call
                after: result!.page!.after! 
            }
        })
        txs.push(...result.balances)
    }

    // Extracting the account addresses
    const addresses = txs.map((item: any) => "'"+item.accountAddress+"'");

    // Saving to the file system
    fs.writeFile('addresses.txt', "["+addresses.join(',') + "]", (err: any) => {
        if (err) {
            console.error('Error writing to file:', err);
        } else {
            console.log('Saved account addresses to addresses.txt');
        }
    });
})()

```

The output will be a file with all the addresses in a javascript based list.

## 2. Create a Collectible Contract & Collection

Next, you'll need to create a Collection in [Sequence Builder](https://sequence.build/) with artwork uploaded to the platform.

Follow [this walk-through](/solutions/builder/collections) in order to store your Collection with Sequence.

## 3. Deploy a Token Sale

Once you have a Collection deployed, the next step is to deploy a Token Sale contract from the token sale factory that is pre deployed at address: `0x19f21cf01d955b0e806e5129174b46b037d99928`

You will need to write to the contract from within the [Sequence Builder](https://sequence.build) with the correct parameters.

Direct yourself to [Builder](https://sequence.build) and Link a contract

<div style={{ display: "flex", justifyContent: "center", alignItems: "center", width: "100%" }}>
	<img style={{clipPath: 'polygon(0% 5px, 100% 5px, 100% 100%, 0% 100%)'}} src="/img/guides/token-sale/builder_link_contract.png" alt="trust mental model" />
</div>

Input the contract address `` making sure `Include unknown contracts` and `Include testnets` is selected

![link contract input](/img/guides/token-sale/builder_link_contract_input.png)

Finally scroll down and select `+ Select`

Then click into the contract and navigate to the `Write Contract` section of the contract

And you'll need to upload an ABI to the builder by selecting `View / Edit ABI`

Select `Edit` then upload the following ABI

```
[{"inputs":[{"internalType":"address","name":"factoryOwner","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"proxyAddr","type":"address"}],"name":"ERC1155SaleDeployed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"beacon","outputs":[{"internalType":"contract UpgradeableBeacon","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"proxyOwner","type":"address"},{"internalType":"address","name":"tokenOwner","type":"address"},{"internalType":"address","name":"items","type":"address"}],"name":"deploy","outputs":[{"internalType":"address","name":"proxyAddr","type":"address"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"implementation","type":"address"}],"name":"upgradeBeacon","outputs":[],"stateMutability":"nonpayable","type":"function"}]
```

Access the `deploy` method card and input the following details
- `proxyOwner`: the user address updating the state of the sale details
- `tokenOwner`: the owner whom the funds go to
- `items`: the contract address of the collectible

Once deployed, access your transaction history of the wallet you deployed from at the [Sepolia Arbiscan](https://sepolia.arbiscan.io/)

And look for the event `ERC1155SaleDeployed(proxyAddr)` that was emitted with the upgradeable proxy deployed, which is the Token Sale contract.

Then, `Link` this additional contract to the Builder using the same steps as prior.

## 4. Clone a Template Frontend

Next, you'll need a frontend, which you can clone down from the following [template Sticker Token Sale repo]() 

Input your access key on the following line, accessible from the [Builder](/solutions/builder/getting-started#step-3-optional-for-development-claim-an-api-access-key)

Update the `token IDs` and `image URLs` (which can be sourced from the Collections tab of the [Sequence Builder](https://sequence.build)) at the [following line]()

## 5. Setup a Merkletree Proof Generating Cloudflare Worker

In order to to generate a proof that is used to input into the contract, a merkletree has to be computed by the [`merkletreejs` npm package](), where necessary functions from `keccak256` are required in the raw code of the cloudflare Worker, along side your added address list.

```typescript
import { MerkleTree } from 'merkletreejs'
import { ethers, utils } from 'ethers'

// copy and pasted code from /node_modules/keccak256/src/keccak256.ts
// where the window code was removed

//@ts-ignore
import BN from 'bn.js'

//@ts-ignore
import createKeccakHash from 'keccak'

function keccak256 (value: Buffer | BN | string | number) {
  value = toBuffer(value)
  return createKeccakHash('keccak256').update(value as Buffer).digest()
}

const generateTree = (elements: string[]) => {
  
    const hashed = elements.map(e => getLeaf(e))

    const merkleTree = new MerkleTree(hashed, keccak256, {
      sort: true,
      sortPairs: true,
      sortLeaves: true,
    })
  
    return {
      merkleTree,
      root: merkleTree.getHexRoot(),
    }
}

const addressList = /*replace with your address list generated in step 1.*/

const tokenId = ethers.constants.MaxUint256
      
const elements: any[] = addressList.map(address => ({
    address,
    tokenId: tokenId,
}))

const tree = generateTree(elements)
```

Where in the code a proof is validated amongst the merkle tree using the address and tokenID

```typescript
const generateProof = (tree: MerkleTree, element: any) =>
    tree.getHexProof(  utils.solidityKeccak256(
      ['address', 'uint256'],
      [element.address.toLowerCase(), element.tokenId.toString()],
    ))
```

## 6. Mint Coins to Wallet

## 7. Mint Collectible to Wallet