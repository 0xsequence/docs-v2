import { Callout } from "vocs/components";

# Treasure Chests with AI Minting

Time to complete: 50-60 minutes

In this guide we will go through the process of creating a web2/web3 enabled react app, leveraging tools from the Sequence Stack to mint AI generated loot from treasure chests using an Embedded Wallet for authentication.

<Callout type="info">
  You can play a live version of the game [here](https://0xsequence-demos.github.io/demo-dungeon-minter/)

  Where the full code can be found in the respective repositories
  - [Web3 react dapp](https://github.com/0xsequence-demos/demo-dungeon-minter)
  - [Template Embedded Wallet](https://github.com/0xsequence-demos/template-embedded-wallet-web2-auth)
  - [Cloudflare worker](https://github.com/0xsequence-demos/demo-cloudflare-worker-treasure-chests/)
  - [Diablo loot API](https://github.com/0xsequence-demos/integration-diablo-loot-api)
</Callout>

The tools will enable you to perform:

1. [Sequence Builder Console Signup & Project Creation](/guides/treasure-chest-guide#1-sequence-builder-console-signup--project-creation): Create a project with the Builder
2. [Access Key Management](/guides/treasure-chest-guide#2-access-key-management): Claim a public, secret access key, and waas config key to interact with the Sequence stack
3. [Embedded Wallet Integration](/guides/treasure-chest-guide#3-embedded-wallet-integration): Integrate an Embedded Wallet into the application
4. [Deploy a Contract & Sponsor gas](/guides/treasure-chest-guide#4-deploy-a-contract--sponsor-gas): Deploy an items contract and sponsor gas
5. [Deploy a Cloudflare Worker](/guides/treasure-chest-guide#5-deploy-a-cloudflare-worker): Deploy a cloudflare worker for gasless and no-confirmation transactions
6. [Generating AI Prompts & Images](/guides/treasure-chest-guide#6-generating-ai-prompts--images): Craft AI prompts from an API and generate images to be uploaded
7. [Store Media to Sequence Metadata service](/guides/treasure-chest-guide#7-store-media-to-sequence-metadata-service): Upload collection and token metadata to Sequence
8. [Securing your Cloudflare Worker](/guides/treasure-chest-guide#8-securing-your-cloudflare-worker): Prevent outside requests to your cloudflare worker by restricting the referrer
9. [(Optional) Naive Mint Restriction Per Wallet](/guides/treasure-chest-guide#9-optional-naive-mint-restriction-per-wallet): Restrict daily mints per wallet

## 1. Sequence Builder Console Signup & Project Creation

First start by following [this walkthrough](/solutions/builder/project-management) for how to sign up to the [Sequence Builder Console](https://sequence.build/) and to learn how to create a project.

In order to use certain features, like `Gas Sponsoring` and the use of the `Transaction API`, you'll need to upgrade your project plan to `Developer` [using this walkthrough](/solutions/builder/project-settings#5-billing-settings)

## 2. Access Key Management

Now that you have a project, you'll need to acquire 3 different Access Keys for your project.
1. `Waas Config Key` used for the Embedded Wallet, which can be learned about [here](/solutions/builder/embedded-wallet)
2. `Public Access Key` used for the Embedded Wallet & Transaction API, which can be done [here](/solutions/builder/getting-started#claim-an-api-access-key)
3. `Secret Access Key` used for the Metadata Service, with the following steps

::::steps
### Access settings
First start by accessing settings, and selecting the API Keys

![builder settings access keys](/img/builder/builder_settings_access_keys.png)

### Add service account

Scroll down and select `+ Add Service Account`

![builder settings add service account](/img/builder/builder_settings_add_service_account.png)

### Select write permission
Then change the access to `Write` and `Confirm`

![builder settings add service account](/img/builder/builder_settings_add_service_account_confirm.png)

Finally `copy` the key and store it in a safe location, as you will not have access to this in the future from the Builder Console.

::::

## 3. Embedded Wallet Integration

<Callout type="info">
You can view and clone the template repository [here](https://github.com/0xsequence-demos/template-embedded-wallet-web2-auth)
</Callout>

We'll start from scratch building up the project with the necessary pieces. 

First start by creating a project folder with `mkdir <project>`, then `cd <project>` and create a `vite` project using:

```shell
pnpm create vite

# or 
yarn create vite

# or 
npm create vite
```

Next, we'll install the correct packages to use the Embedded Wallet.

```shell
pnpm install @0xsequence/waas

# or
npm install @0xsequence/waas

# or
yarn add @0xsequence/waas
```
All of the new files created in the follows steps, have them created in `/src`

First create a file called something like `SequenceEmbeddedWallet.ts` with the following initialization code

```typescript
import { SequenceWaaS } from '@0xsequence/waas'

const sequence = new SequenceWaaS({
    projectAccessKey: import.meta.env.VITE_PROJECT_ACCESS_KEY!,
    waasConfigKey:  import.meta.env.VITE_WAAS_CONFIG_KEY!,
    network: 'arbitrum-nova'
})

export default sequence;
```

Then create another file called `useSessionHash.ts` that generates a session hash from the SDK unique to the user

```typescript
import sequence from './SequenceEmbeddedWallet.ts'
import { useEffect, useState } from "react";

export function useSessionHash() {
    const [sessionHash, setSessionHash] = useState("")
    const [error, setError] = useState<any>(undefined)

    useEffect(() => {
        const handler = async () => {
            try {
                setSessionHash(await sequence.getSessionHash())
            } catch (error) {
                console.error(error)
                setError(error)
            }
        }
        handler()
        return sequence.onSessionStateChanged(handler)
    }, [setSessionHash, setError])

    return {
        sessionHash,
        error,
        loading: !!sessionHash,
    }
}
```

Finally, to implement Google auth, you will need the `GoogleOAuthProvider` to wrap your application

Which can be installed with the following command, where the apple auth sign in will be used later

```shell
pnpm i @react-oauth/google react-apple-signin-auth
```

And implemented with the previous imported files, in the following code in the `main.tsx` file

```typescript
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'
import App from './App.tsx'
import { useSessionHash } from "./useSessionHash.ts";

import { ThemeProvider } from '@0xsequence/design-system'
import { GoogleOAuthProvider } from '@react-oauth/google'


function Dapp() {
  const { sessionHash } = useSessionHash()

  return (
	<GoogleOAuthProvider clientId="<GOOGLE_CLIENT_ID>" nonce={sessionHash} key={sessionHash}>
		<App />
	</GoogleOAuthProvider>
  );
}

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <Dapp />
  </React.StrictMode>
)
```

Once your `main.tsx` is ready, lets create the login buttons

In `App.tsx` use the following code that checks to see if a user is connected and presents a wallet address based on the signed in user, with the various social auth buttons and handlers

```typescript
import { useState, useEffect } from 'react'
import './App.css'
import sequence from './SequenceEmbeddedWallet'
import { useSessionHash } from './useSessionHash'
import { CredentialResponse, GoogleLogin } from '@react-oauth/google';
import AppleSignin from 'react-apple-signin-auth';
import playImage from './assets/play.svg'

function LoginScreen () {
  const { sessionHash } = useSessionHash()

  const [wallet, setWallet] = useState<any>(null)
  const [googleHover, setGoogleHover] = useState(false)
  const [appleHover, setAppleHover] = useState(false)

  const handleGoogleLogin = async (tokenResponse: CredentialResponse) => {
    const res = await sequence.signIn({
      idToken: tokenResponse.credential! // inputted id credential from google
    }, "template")
    setWallet(res.wallet)
  }

  const handleAppleLogin = async (response: any) => {
    const res = await sequence.signIn({
      idToken: response.authorization.id_token! // inputted id token from apple
    }, "template")
 
    setWallet(res.wallet)
  }

  // checks to see if there is a logged in user
  useEffect(() => {
    setTimeout(async () => {
      if(await sequence.isSignedIn()){
        setWallet(await sequence.getAddress())
      }
    }, 0)
  }, [])

  useEffect(() => {

  }, [googleHover, appleHover, wallet])

  return (
    <>
      {
        !wallet 
      ? 
        <>
          <span className='sign-in-via'>SIGN IN VIA</span>
          <br/>
          <br/>
          <br/>
          <div className="login-container">
          <div className='dashed-box-google'>
              <p className='content'>
                <div className='gmail-login' onMouseLeave={() => setGoogleHover(false)} onMouseEnter={() => {setGoogleHover(true)}} style={{overflow: 'hidden', opacity: '0',width: '90px', position: 'absolute', zIndex: 1, height: '100px'}}>
                  {
                  googleHover && <GoogleLogin 
                    nonce={sessionHash}
                    key={sessionHash}
                    onSuccess={handleGoogleLogin} shape="circle" width={230} /> }
                  </div>
                  <span className='gmail-login'>Gmail</span>
                  {googleHover && <img src={playImage} alt="Play" className="play-image-gmail" />}
              </p>
          </div>
          <div className='dashed-box-apple'>
            <p className='content' 
            onMouseLeave={() => setAppleHover(false)} 
            onMouseEnter={() => {setAppleHover(true)}}
            style={{position:'relative'}}>
                <span className='apple-login'>
                  {/* @ts-ignore */}
                  <AppleSignin
                    key={sessionHash}
                    authOptions={{
                      clientId: '<replce with com. bundle id>',
                      scope: 'openid email',
                      redirectURI: '<must be a deployed URL>',
                      usePopup: true,
                      nonce: sessionHash
                    }}
                    onError={(error: any) => console.error(error)}
                    onSuccess={handleAppleLogin}
                  />Apple
                </span>
                {appleHover && <img src={playImage} alt="Play" className="play-image-apple" />}
            </p>
            </div>
          </div>
        </>
      : 
        <p>{wallet}</p>
      }
    </>
  )
}

function App() {
  return (
    <LoginScreen/>
  )
}

export default App
```

Then, include a `.env` file in the root of your project, adding it to `.gitignore`, then updating the file with the following values:

```
VITE_PROJECT_ACCESS_KEY=
VITE_WAAS_CONFIG_KEY=
```

<Callout type="warning">
All environment variables must start with `VITE_` to be included
</Callout>

Run your code with the following command in the root folder and give it a try:

```shell
pnpm run dev
```

## 4. Deploy A Contract & Sponsor Gas

When deploying your contract, the recommended approach is to use an `ERC1155` over an `ERC721`. The benefits of using an `ERC1155`

- random spaced `tokenID` to allow for parallelized minting
- option via consent to apply governance to mint additional tokens of the same `tokenID`

However, if you plan to only ever mint a single token of the generated media and you prefer technical security in managing parallelized minting over managing the security of the transactions API private key (which can always be rotated by setting a new collectible `role` via the [Sequence Builder](https://sequence.build/)) an ERC721 might be better suited.

To deploy a contract, you can follow [this guide](/solutions/collectibles/contracts/deploy-an-item-collection) to deploy your ERC1155, and update your `wrangler.toml` with the `CONTRACT_ADDRESS`

And to sponsor gas, follow [this guide](/solutions/builder/gas-tank#watch-the-gas-tank-in-action-in-builder)

## 5. Deploy A Cloudflare Worker

### Minting A Token
If you want to learn how to deploy a Cloudflare Worker from scratch, you can follow [this guide](/guides/mint-collectibles-serverless) on minting a serverless gasless minter with your deployed `ERC1155` contract

### Add Treasure Chest Object Composition

Next, ensure that you can mint a token by making a request to the cloudflare API. Then, add the additional object composition design to include the treasure chest specific functions, where the prior cloudflare worker can be integrated into this template [template treasure chest cloudflare worker](https://github.com/0xsequence-demos/demo-cloudflare-worker-treasure-chest/tree/template). 

In this codebase (which has optional design), we use a style of javascript to assemble javascript object in a functional manner which can be seen here

Where in the following sections, we will complete the functions:
- `ProcessInferencePool`: used to source loot metadata seed values from an external api
- `Inference`: used to generate AI imagery and to check the status an in-progress inference
- `Upload`: used to store metadata for future retrieval

```js
let treasureChest = ProcessInferencePool(
				Inference(
					Upload(
						{
							env: env
						}
					)
				)
			)
```

## 6. Generating AI Prompts & Images

In the template, we've included code to call an already deployed API and code to parse the response that is free to call yourself

With this API, we will showcase how to generate images using the prompt from the deployed diablo API within the `generate` function.

```typescript
const ProcessInferencePool = (base: any) => {
	base.generate = async () => {
		const url = 'https://flask-production-2641.up.railway.app/'; // External API endpoint
		
		const init = {
			method: 'GET',
			headers: {
			'Content-Type': 'application/json',
			},
		};

		const response = await fetch(url, init); // Fetch data from external API
		const data: any= await response.json(); 
		const defend = Math.random() >= 0.5 ? true : false
	  	const attributes = []
	  	// parse the data to create the attributes
		
		return {loot: data[defend ? 'armor' : 'weapon'], attributes: attributes}
	}
	return {
		...base
	}
}

```

Then by completing the `getInferenceWithItem` function and passing in a `prompt` which is basically the generated loot `name` and `type`, as well as some additional parameters

<Callout type='info'>
For this guide we landed on the `EulerDiscreteScheduler` scheduler type based on quality and time, but if you want to experiment with using additional schedulers, you can use [this custom local cli](https://github.com/moskalyk/scenario-gg-benchmark-cli) and check the results in the [Scenario.gg](https://scenario.gg/) dashboard
</Callout>

```typescript
...
const Inference = (base: any) => {
	return {
		...base,
		getInferenceWithItem: async (prompt: any) => {
			return new Promise( async (res) => {
				fetch(`https://api.cloud.scenario.com/v1/models/${base.env.SCENARIO_MODEL_ID}/inferences`, {
					method: 'POST',
					headers: {
						'Authorization': `Basic ${base.env.SCENARIO_API_KEY}`,
						'accept': 'application/json',
						'content-type': 'application/json'
					},
					body: JSON.stringify({
								"parameters": {
								"numSamples": 1,
								"qualityBoostScale": 4,
								"qualityBoost": false,
								"type": "txt2img",
								"disableMerging": false,
								"hideResults": false,
								"referenceAdain": false,
								"intermediateImages": false,
								"scheduler": 'EulerDiscreteScheduler',
								"referenceAttn": false,
								"prompt": prompt + ' single object on black background no people' // update this to your choosing
							}
						})
				})
				.then(response => response.json())
				.then((data: any) => {
					res({inferenceId: data.inference.id})
				})
				.catch(error => console.error('Error:', error));
			})
		}
		...
	}
}	
```

Generating the loot from the treasureChest API and calling the method like so to return an `inferenceId`

```js
	...
	if(mint){
		...
	} else {
		const loot = await treasureChest.generate()
		const inferenceId = await treasureChest.getInferenceWithItem(loot.loot.name + " " + loot.loot.type)
		...
	}
	...
```

Once we have the `inferenceId` we can call poll the inference status and return when complete

```typescript
const Inference = (base: any) => {
	return {
		...base,
		getInferenceWithItem: async (prompt: any) => {
			...
		},
		getInferenceStatus: (id: any) => {
			const pollInferenceStatus = async (res: any) => {
				let status = '';
				let inferenceData: any = null;

				// checking if the status is succeeded or failed
				while (!['succeeded', 'failed'].includes(status)) {
					// Fetch the inference details
					try {
						const inferenceResponse = await fetch(`https://api.cloud.scenario.com/v1/models/Fm1gtd_gRwmopwj2gyWtUA/inferences/${inferenceId}`, {
							method: 'GET',
							headers
						});
						if (inferenceResponse.ok) {
							console.log(inferenceResponse.statusText)
							inferenceData = await inferenceResponse.json();
							
						}
					}catch(err){
						console.log(err)
					}
					status = inferenceData.inference.status;
					console.log(`Inference status: ${status}`);

					// Wait for a certain interval before polling again
					await new Promise(resolve => setTimeout(resolve, 5000)); // Polling every 5 seconds
				}
				// Handle the final status
				if (status === 'succeeded') {
					console.log('Inference succeeded!');
					console.log(inferenceData); // Print inference data
					res(inferenceData)
				} else {
					console.log('Inference failed!');
					console.log(inferenceData); // Print inference data
					throw new Error("Scenario API Failed")
				}
			};
			// Start polling the inference status
			await pollInferenceStatus(res);
		}
	}
}
```
and call the `getInferenceStatus` with the `inferenceId` passed in, where when you receive the response, you can obtain the image url with `resObject.inference.images[0].url`

```typescript
	...
	if(mint){
		...
	} else {
		const loot = await treasureChest.generate()
		const inferenceId = await treasureChest.getInferenceWithItem(loot.loot.name + " " + loot.loot.type)
		const resObject = await treasureChest.getInferenceStatus(inferenceId)
		console.log(resObject.inference.images[0].url) // prints image url
		...
	}
	...
```

## 7. Store Media to Sequence Metadata Service

With our media `url` in hand, we can move onto storing the asset to the `Sequence Metadata Service`

Complete and integrate [this guide](/guides/metadata-guide) in order to build a Serverless Media Service that uses Cloudflare Workers

Then once complete, pass the stored media url to the frontend

```typescript
	...
	const response = await someStoreFunction(...)
	return new Response(JSON.stringify({... image: response.url, tokenID: response.tokenID}), { status: 200 });
```

## 8. Securing your Cloudflare Worker

In order to secure your cloudflare worker to only process requests from a certain frontend origin, you can simple check the `request.headers` for the `Referrer` value and compare against the `CLIENT_URL` in the `wrangler.toml`

```typescript
async function handleRequest(request: any, env: Env, ctx: ExecutionContext) {
	const originUrl = new URL(request.url);
	const referer = request.headers.get('Referer');

	if(referer.toString() == env.CLIENT_URL){
		...
	} else {
		return new Response('Bad Origin', { status: 500 }); // Handle errors
	}
}
```

## 9. (Optional) Native Mint Restriction Per Wallet

As an option to prevent overuse of the treasure chest minting from specific wallets, a parameter called `DAILY_MINT_RESTRICTION` can be set in the `wrangler.toml` as a maximum mint allowance per day. And, if you feel it's necessary adding an `ADMIN` to your protocol, to be able to in the future mint to a marketplace, this can be included too.

These features can be implemented in the code with the following steps:

```typescript
async function handleRequest(request: any, env: Env, ctx: ExecutionContext) {
	... 
	const payload = await request.json()
	const { address, tokenID }: any = payload

	// check for admin
	if(address.toLowerCase() != env.ADMIN.toLowerCase()){
		// check for daily mint allowance
		if(!await hasDailyMintAllowance(env, address)){
			return new Response(JSON.stringify({limitExceeded: true}), { status: 400 })
		}
	}
	...
}
```

Where `hasDailyMintAllowance` is broken down into 2 functions:
- `fullPaginationDay` of transactions of the users `address`
- `mintCount` that corresponds to the `from` being the `0x` address

### Full Pagination Of Indexer For A Day
<Callout type='info'>
	As an aside, the Sequence Indexer stack only holds 30 days of transactions for this period, so you can extend the time frame from a day up to this max
</Callout>

In order to use the Sequence Indexer, we'll need to `pnpm install @0xsequence/indexer`

Then, to implement we use a while loop that gets the first batch of transactions and the `page.after` value from the indexer, and continously checks if the timestamp is less than 24 hours appending to a temporary array for each pass. This ensures we get all of the available transactions.

```typescript
import { SequenceIndexer } from '@0xsequence/indexer'

const isLessThan24Hours = (isoDate: string) => {
    const dateProvided: any = new Date(isoDate);
    const currentDate: any = new Date();
    const twentyFourHours = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

    // Calculate the difference in milliseconds
    const difference = currentDate - dateProvided;

    // Check if the difference is less than 24 hours
    return difference < twentyFourHours && difference > 0;
}

const fullPaginationDay = async (env: Env, address: string) => {
    const txs: any = []
	const indexer = new SequenceIndexer(`https://${env.CHAIN_HANDLE}-indexer.sequence.app`, env.PROJECT_ACCESS_KEY)

    const filter = {
        accountAddress: address,
    };

    // query Sequence Indexer for all token transaction history
	let txHistory: any
	let firstLoop = true;
    let finished = true;
    // if there are more transactions to log, proceed to paginate
    while(firstLoop || (!finished && txHistory.page.more)){  
		if(firstLoop){
			firstLoop = false
			txHistory = await indexer.getTransactionHistory({
				filter: filter,
				page: { pageSize: 50 }
			})

			for(let i = 0; i < txHistory.transactions.length; i++){
				if(!isLessThan24Hours(txHistory.transactions[i].timestamp)){
					finished = true
				}
				txs.push(txHistory.transactions[i])
			}
		}
        txHistory = await indexer.getTransactionHistory({
            filter: filter,
            page: { 
                pageSize: 50, 
                // use the after cursor from the previous indexer call
                after: txHistory!.page!.after! 
            }
        })
		for(let i = 0; i < txHistory.transactions.length; i++){
			if(!isLessThan24Hours(txHistory.transactions[i].timestamp)){
				finished = true
			}
			txs.push(txHistory.transactions[i])
		}
    }

    return txs
}
```
### Mint Count For A Day
All collectibles minted from the `ERC721` and `ERC1155` standard Sequence contracts are `from` the `0x` address

```typescript
const mintCount = (env: Env, txs: any) => {
	let count = 0
	for(let i = 0; i < txs.length; i++){
		if(
			txs[i].transfers[0].from == '0x0000000000000000000000000000000000000000' 
			&& txs[i].transfers[0].contractAddress == env.CONTRACT_ADDRESS.toLowerCase()
		) count++
	}
	return count
}
```

### Has Daily Mint Allowance

```typescript
const hasDailyMintAllowance = async (env: Env, address: string) => {
	const txs = await fullPaginationDay(env, address)
	const count = mintCount(env, txs)
	return count < env.DAILY_MINT_RESTRICTION
}
```