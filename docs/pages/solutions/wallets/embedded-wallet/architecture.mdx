# Overview

## Embedded Wallet Architecture

Sequence Embedded Wallets are native smart contract multisig wallets. The configuration of the multisig is 2/2, where both parties are required to sign in order to submit a transaction. 

Unlike the more traditional MPC architecture where the keys are first created together and then separated, Sequence WaaS keys are always kept separate and never have to be combined to sign.

On top of this core security layer, Sequence WaaS architecture offers additional protections:

- **Signer 1: Sequence Auth:** Running in an encrypted AWS Nitro Enclave, Sequence Auth acts as the first signer and it's locked into the latest publicly audited version by Quantstamp. Sequence doesn't have the ability to access the enclave or push updates to it without Quantstamp's approval.
- **Signer 2: Sequence Guard:** Running independently from Sequence Auth, Guard is capable of reviewing both the user's identity and intent before signing transactions.
- **OpenID Connect Compatibility:** Sequence WaaS leverages established OpenID Connect providers such as Google, Apple and any other provider that follows the same protocol. Unlike any other solution on the market, WaaS also allows developers to leverage their own OIDC identifiers with these services. So you have full access to the user profiles created.

## Sequence Auth
**Add Authentication Features:** Implement Sequence Auth to manage account creation, login, session management, and wallet integration. Sequence Auth is an API service that runs on the [AWS Nitro Enclaves](https://aws.amazon.com/ec2/nitro/nitro-enclaves/) platform. 

**Encrypt Data:** Wallet private keys are stored encrypted using a split responsibility strategy between Sequence and Quantstamp: Sequence is able to access only the encrypted blobs stored in the database with no means of decryption. Quantstamp owns and operates the [KMS](https://aws.amazon.com/kms/) (AWS hardware security module) used to encrypt the wallet key data. They have no way to export the key material and no access to the encrypted data itself.

**Verify Integrity:** The WaaS Enclave is the only entity able to use the encrypted wallet data. Both the hosting on a cryptographically attested secure enclave on Amazon Nitro and the availability of the audited code help developers verify without trusting Sequence. 

## Signer 2: Sequence Guard

Sequence Guard is a service hosted by Sequence and contains the other key of the wallets. It's meant to be another line of defense, verifying not only user's _identity_ but also their _intent_. It achieves this in two different ways:

- **Add Scope with Limits and Allowlists:** Set up Sequence Guard to manage transaction permissions through limits and allowlists in the development dashboard. Specify allowable actions, such as engaging with certain contracts, to ensure that Guard only authorizes these specified transactions.
- **Independently Authenticate Users:** Enable Sequence Guard to verify user identity and intent separately from Sequence Auth, using either third-party OAuth 2.0 id tokens or direct communication for OTP verification. Tailor these interactions to fit your project’s branding and security needs.

### Threat model
The threat model for Sequence Wallets offers:
- **Full Protection Scenarios:**
    - **Backend Compromise or Guard Key Leak:** Sequence Auth still verifies user identities, ensuring wallet security.
    - **Sequence Auth Compromise:** Sequence Guard independently authenticates users, blocking unauthorized access.
- **Partial Protection Scenario:**
    - **Partner Frontend Compromise or MITM on Partner Side:** Attackers may access wallets at login but cannot reach wallets of inactive users, allowing for potential recovery with limited damage.

## WaaS API Service

- **Deploy WaaS API:** Sequence WaaS (Wallet as a Service) is an API service that runs on the [AWS Nitro Enclaves](https://aws.amazon.com/ec2/nitro/nitro-enclaves/) platform and allows for secure wallet management. It is the technology that powers the [Embedded Wallet](https://docs.sequence.xyz/solutions/wallets/embedded-wallet/overview).
- **Encrypt and Store Private Keys:** A split responsibility strategy for encryption. Sequence accesses encrypted blobs stored in the database, and a Trusted Third Party operates the Key Management System (KMS). They have no way to export the key material and no access to the encrypted data itself.
- **Ensure Data Security:** The WaaS Enclave is the only entity able to use the encrypted wallet data, and is bolstered by AWS Nitro hypervisor's cryptographic attestations. This includes a PCR0 hash that must match expected values for operation, ensuring that even minor changes to the enclave invalidate its operation.
- **Audit and Verify:** Review the open-source enclave code to confirm the service adheres to the verified, audited version, enhancing trust and security verification.

## Data Flow for a Transaction on the WaaS System
Below we illustrate the data flow of a common use case such as signing a transaction via embedded wallets.

![data-flow-architecture](/img/diagrams/waas/waas-flow.png)
:::note
Simplified layout describing the lifecycle of a transaction on the WaaS system.
Blue: Software provided by the partner
Orange: Software provided by Sequence but run and managed by the partner
Yellow: Software provided and run by Sequence in a secure AWS Nitro Enclave
Green: Software provided and run by Sequence
:::

#### Step 1. Generation of the Intent

The user interacts with the client to "do something" that requires an action on behalf of the wallet (i.e. send some USDC or call a contract method). The client uses waas sdk to generate an intent. The client signs this intent with its session keys.

#### S### Step 2: Client Sends Intent and Backend Authenticates User

The client sends the intent and its signature to the partner's backend. The backend authenticates the user.

### Step 3: Backend Forwards Intent and PSS Validates Transaction

The partner's backend forwards the intent to the Partner Signing Service (PSS) in the Nitro Enclave. PSS asks the WaaS API to build a transaction. PSS checks the transaction matches the intent. PSS signs the transaction with the partner's hotkey. PSS sends the transaction, intent, and signature to the WaaS API.

#### 4. WaaS API Collects Signature from Sequence Guard

The WaaS API receives the half-signed transaction and the client-signed intent. The WaaS API calls the guard to collect one more signature before being able to relay the transaction, so it calls Sequence Guard.

#### 5. Sequence Guard Authenticates the User

The guard gets a signature request. The guard verifies the intent matches the transaction and a valid session signed it. If correct, the guard signs the transaction.

#### 6. Relay and Transaction Receipt
The WaaS API relays the transaction. The WaaS API waits for a receipt. The WaaS API sends the resulting txHash back to the client/backend.
